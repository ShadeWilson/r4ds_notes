{
    "collab_server" : "",
    "contents" : "# Notes from R FOR DATA SCIENCE,\n# an O'Reilly guide by Hadley Wickham and Garrett Grolemund\n# Availible online at http://r4ds.had.co.nz/\n# PART TWO: Wrangle\n# Chapter 10: Relational Data with dplyr\n\n# to work with relational data, need verbs that work with pairs of tables. THree families:\n# 1) mutating joins, which add new variables to one data frame form matching obs from another\n# 2) filtering joins, which filter obs from one df based on whther or not they match an obs in another\n# 3) set operations, which treat obs as if they were set elements\n\nlibrary(tidyverse)\nlibrary(nycflights13)\n\nairlines # shows full carrier names from abbr. code\nairports # gives info on each airport, ID'd by the faa airport code\nplanes # gives info about each plane, ID'd by tailnum\nweather # gives weather at each NYC airport for each hour\n\n######################## Keys ######################## \n# variables used to connect each pair of tables are keys\n# primary keys uniquey identify an obs in its own table(ie. planes$tailnum)\n# foreign keys uniquely ID an obs in another table (ie. flights$tailnum)\n# a variable can be BOTH a primary key and a foreign key (ex: origin is part of weather\n# primary key and is also a foreign key for the airport table)\n\n# tailnum is a primary key that does uniquely ID each observation\nplanes %>%\n  count(tailnum) %>%\n  filter(n > 1)\nweather %>%\n  count(year, month, day, hour, origin) %>%\n  filter(n >1)\n\n# sometimes a table doesn't have an explicit primary key\n# year, month, day, flight is not a unique identifier, nor is year, month, day, tailnum\nflights %>%\n  count(year, month, day, flight) %>%\n  filter(n > 1)\nflights %>%\n  count(year, month, day, tailnum) %>%\n  filter(n > 1)\n\n# if a table lacks a primary key it is sometimes useful to add one with mutate() and row_number()\n# called a surrogate key\n\n# Exercises\n# 2\nlibrary(Lahman)\nBatting %>%\n  count(playerID, yearID, teamID, stint) %>%\n  filter(n > 1)\n\ndiamonds %>%\n  count(cut, color, clarity, table) %>%\n  filter(n > 1) # doesn't look like there is one\n\n######################### Mutating Joins ######################### \n# allos you to combine variable from two tables. ads variables to the right\n\n# make dataset narrower\n(flights2 <- flights %>%\n  select(year:day, hour, origin, dest, tailnum, carrier))\n\n# adding full airline naem to flights2 data using left_join()\n# result is an additional variable (name)\nflights2 %>%\n  select(-origin, -dest) %>%\n  left_join(airlines, by = \"carrier\")\n# could do same thing with mutate and R's base subseting:\nflights2 %>%\n  select(-origin, -dest) %>%\n  mutate(name = airlines$name[match(carrier, airlines$carrier)])\n\n# Understanding joins\nx <- tribble(\n  ~key, ~val_x,\n  1, \"x1\",\n  2, \"x2\",\n  3, \"x3\"\n)\ny <-  tribble(\n  ~key, ~val_y,\n  1, \"y1\",\n  2, \"y2\",\n  4, \"y4\"\n)\n\n# INNER JOIN: simplest type of join, which matches pairs of obs whenever keys are equal\n# equijoin: keys are matched using the equality operator\n# output of join is a new df that contains the key, and both matched values\n# determine key with by = \"\"\nx %>%\n  inner_join(y, by = \"key\")\n# unmatched rows are NOT included! Usually this can't be used in analysis bc too easy to lose obs\n\n# OUTER JOINS: keeps ovs that appear in at least one of the tables. Three types:\n# 1) left join keeps all obs in x\n# 2) right join keeps all obs in y\n# 3) full join keeps all obs in x and y\n# works by adding additional \"virtual\" obs to each table (NA)\n\n# default join should be left_join() bc preserves original obs even when no match\n\n# DUPLICATE KEYS: what happens when keys aren't unique? Two possibilities:\n# 1) One table has duplicate keys\nx <- tribble(\n  ~key, ~val_x,\n  1, \"x1\",\n  2, \"x2\",\n  2, \"x3\",\n  1, \"x4\"\n)\ny <-  tribble(\n  ~key, ~val_y,\n  1, \"y1\",\n  2, \"y2\"\n)\nleft_join(x, y, by = \"key\")\n# 2) both tables have a duplicate key. usually an error\nx <- tribble(\n  ~key, ~val_x,\n  1, \"x1\",\n  2, \"x2\",\n  2, \"x3\",\n  3, \"x4\"\n)\ny <-  tribble(\n  ~key, ~val_y,\n  1, \"y1\",\n  2, \"y2\",\n  2, \"y3\",\n  3, \"y4\"\n)\nleft_join(x, y, by= \"key\") # get all possible combos of the duplicate keys (Cartesian product)\n\n# Defining the key Columns\n# other ways to join other than using single variable (by = \"key\")\n\n# default (by = NULL) uses all variables that appear in both tables (natural join)\n# ex: flights and weather match on their common variables: year, month, day, hour, origin\nflights2 %>%\n  left_join(weather)\n\n# a character vector, by = \"x\". This is like natural join but only uses some of the common variables\n# ex: flights and planes have year variables, but mean diff things so we only want tailnum\n# note year variables are disambiguated in the output w/ suffix\nflights2 %>%\n  left_join(planes, by = \"tailnum\")\n\n# a named character vector: by = c(\"a\" = \"b\"). This matches variable a in table.x to var b\n# in table.y. Variables from x will be used in output\n# ex: for drawing map, need to combine the flight data with the airports data (lat and long)\n# each flight has origin and dest airport, so we need to specify\nflights2 %>%\n  left_join(airports, c(\"dest\" = \"faa\"))\nflights2 %>%\n  left_join(airports, c(\"origin\" = \"faa\"))\n\n# Exercises\n# 1\nflights %>%\n  filter(!is.na(dep_delay), !is.na(arr_delay)) %>%\n  group_by(dest) %>%\n  summarize(avg_dep_delay = mean(dep_delay)) %>%\n  left_join(airports, by = c(\"dest\" = \"faa\")) %>%\n  filter(!is.na(name)) %>%\n  ggplot(aes(lon, lat)) +\n    borders(\"state\") +\n    geom_point(aes(color = avg_dep_delay, size = avg_dep_delay)) +\n    coord_quickmap()\n\n# 2\nairports %>%\n  select(faa, lat, lon) %>%\n  right_join(flights, by = c(\"faa\" = \"dest\")) # or\n# better\nflights %>%\n  left_join(airports, by = c(\"dest\" = \"faa\")) %>%\n  select(-name, -(alt:tzone))\n# 3\n# add plane age column\nplanes2 <- planes %>%\n  mutate(age = 2013 - year) %>%\n  select(tailnum, age)\nflights %>% \n  filter(!is.na(dep_delay), !is.na(arr_delay)) %>%\n  group_by(tailnum) %>%\n  summarize(avg_delay = mean(arr_delay - dep_delay),\n            count = n()) %>%\n  left_join(planes2, by = \"tailnum\") %>%\n  filter(!is.na(age), count > 20, age < 30) %>% # take out NAs and outliers, zoom in\n  ggplot(aes(x = age, y = avg_delay)) +\n    geom_jitter(aes(color = count)) +\n    geom_smooth(se = FALSE)\n# 4\nflights %>% \n  filter(!is.na(dep_delay), !is.na(arr_delay)) %>%\n  left_join(weather, by = c(\"year\", \"month\", \"day\", \"hour\")) %>%\n  filter(month == 1) %>%\n  ggplot(aes(dep_delay, wind_speed)) +\n    geom_point()\n\n# Other implementations\n# base::merge() can perform all 4 types of mutating joins, but dplyr's are more clear and faster\n\n######################### Filtering Joins #########################\n# filtering joins affect obs, not the variables. Two types:\n# 1) semi_join(x, y) keeps all obs in x that have a match in y\n# 2) anti_join(x, y) drops all obs in x that have a match in y\n\n# semi joins are useful for matching filtered summary tables back to the original rows. \n# ex: imagine you've found top 10 most popular dests\ntop_dest <- flights %>%\n  count(dest, sort = TRUE) %>%\n  head(10)\n# now you want to find each flight that went to one of those dests. Could filter yourself\nflights %>%\n  filter(dest %in% top_dest$dest)\n# this is difficult to extend to multiple cars though. instead , use semi_join()\n# connects two tables like a mutating join, but instead of adding new columns, \n# only keeps the rows in x that have a match in y\nnycflights13::flights %>%\n  semi_join(top_dest)\n\n# anti_joins are the oppositee of a semi_join: only gives obs that DONT have a match\n# useful for diagnoseing join mismatches\n# ex: checking flights that don't have a match in planes\nflights %>%\n  anti_join(planes, by = \"tailnum\") %>%\n  count(tailnum, sort = TRUE)\n\n# Exercises\n# 1: almost all have the same carrier: MQ\n# 2\nmany <- flights %>%\n  count(tailnum) %>%\n  filter(n >= 100)\n\nflights %>%\n  semi_join(many) \n  \n# Set Operations: expect x and y inputs to have the same variab;les and treat obs like sets\n# intersect(x, y) returns only observations in both x and y\n# union() returns unique obs in x and y\n# setdiff() returns obs in x, but not y\ndf1 <- tribble(\n  ~x, ~y,\n  1, 1,\n  2, 1\n)\ndf2 <- tribble(\n  ~x, ~y,\n  1, 1,\n  1, 2\n)\n# Four possibilities\nintersect(df1, df2)\n\nunion(df1, df2)\n\nsetdiff(df1, df2)\n\nsetdiff(df2, df1)\n",
    "created" : 1504995058536.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3983543659",
    "id" : "1DC69307",
    "lastKnownWriteTime" : 1501510790,
    "last_content_update" : 1501510790,
    "path" : "~/Desktop/Coding/R/r4ds/r4ds_chp10_relational_data.R",
    "project_path" : "r4ds_chp10_relational_data.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}